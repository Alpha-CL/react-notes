# Redux

#### MVC

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


React                   // 组件化 UI 界面处理方案

React-Router            // 根究地址匹配路由，渲染不同组件的页面

Redux                   // 处理数据及数据变化方案( 主要处理共享数据 )
  - redux-saga          // 处理数据异步方案
  - redux-actions       // 简化 action & reducer 书写方案
 

Antd                    // 后台框架 解决方案


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * MVC
 * 
 * 
 * UI 解决方案: 用于降低 UI，及 UI关联数据的复杂度
 */

/** old_resolve: 服务端MVC( model view coontroller ) **/

1) 服务器接收到请求
2) 将请求分发到对应的 controller
3) contoller 根据请求整理 数据模型，交给 view
4) view 根据 数据模型，返回 最终完整的HTML


    + ------- +           + ------ +            控制器: 收到不同请求，将不同请求分发对应到 controller
    |         |           |        |        + ------------------------ +
    |         |           |        |        |                          |
    |         |  request  |        | -----> |        Controller        |
    |         | --------> |        |        |                          |
    |         |           |        |        + ------------------------ +
    | Browser |           | Server |                             |
    |         |           |        |                            \|/
    |         |           |        |        + ------ +       + ------- +
    |         | <-------  |        |        |        |       |         | 数据模型
    |         |  response |        | <----- |  View  | <---- |  Model  |
    |         |           |        |        |        |       |         |
    |         |           |        |        + ------ +       + ------- +
    + ------- +           + ------ +        视图: 结合数据
                                                 返回完整HTML
                             

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
            

/** 前端 MVC 难点 **/

React 解决了 Model -> View 的问题

1) 前端的 controller 要比服务器复杂很多，因前端中 controller 处理的是用户操作( 相对复杂 )

2) 对于组件化框架(vue, react)，通常使用单向数据流，若需要共享数据
   则必须将数据提升到顶层组件，再将数据一层一层传递，及其繁琐
   虽然利用 上下文实现数据共享，但对数据操作难以监控，数据错误调试及数据还原依然很难控制
   ( 在大中型项目中，共享的数据很多，会导致 上下文中的数据变得非常复杂 )


     Problem: 数据操作过于复杂( 事件触发较多 )
       /|\
        |       + ------------------------ +
        |       |                          |
        |       |        Controller        |
        |       |                          |
        |       + ------------------------ +
        |           /|\               |
        +----------- |                |
                     |               \|/
                + ------ +       + ------- +
                |        |       |         |
                |  View  | <---- |  Model  |
                |        |       |         |
                + ------ +       + ------- +
                
                |<---- React resolved ---->|


//-------------------------------------------------------------------------------------------------------------------//


/**
 * Flux             // Facebook 提出的数据解决方案
 * 
 * 
 * 在 MVC 的基础上， 引入 action 的概念
 */

        * action: 普通对象( 用于描述要干什么 )，action 是触发数据变化的 唯一原因

                    + ------------------------ +
         action:{}  |                          |
        + --------> |        Controller        |
        |           |                          |
        |           + ------------------------ +
        |                /|\               |
        |                 |                |
        |                 |               \|/
    + -------- +       + ------ +       + ------- +
    |          |       |        |       |         |
    |  Action  | <---- |  View  | <---- |  Model  |
    |          |       |        |       |         |
    + -------- +       + ------ +       + ------- +
                    
    action: {         // 将不同的操作，以一种 同样数据结构 传递给 controller
        type: 'login',
        payload: {
            loginId: 'admin',
            loginPwd: 'password',
        }
    }


//-------------------------------------------------------------------------------------------------------------------//


/**
 * Redux
 * 
 * 
 * 在 Flux 的基础上，引入 reducer 的概念
 */

    * reducer: 处理器，用于根据action来处理数据，处理后的数据会被仓库重新保存

    + ------------ +                + ------------------ +              
    |              |  1) dispatch   |                    |      1) dispatch:        分发 action
    |    Action    | -------------> |       Store        |      2) transfer_action: 传递 action
    |              |                |                    |      3) get_newData:     获取 newData
    |              |                |  4) save_newData   |      4) save_newData:    存储 newData
    |              |                |                    |              
    + ------------ +                + ------------------ +
                                          /|\    |
                          3) get_newData   |     |   2) transfer_action
                                           |    \|/
                                    + ----------------- +
                                    |                   |
                                    |      Reducer      |
                                    |                   |
                                    + ----------------- +


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Action

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * action
 * 
 *
 * 1) action must be 'plain_object'         // action.__proto__ 必须指向 object.prototype
 *
 * 2) action 必须包含 type 属性               // action.type( 未规定是否未 字符串 类型 ) 用于描述如何操作数据
 *
 * 3) 大型项目中，由于操作类型繁多，为了避免硬编码( hard_code )
 *    将 action 的类型存放 在一个或一些 单独的文件中( 样板代码 )
 *
 * 4) 为了方便传递 action，通常使用 function actionFn(): action;
 *      - actionFn(); 应为纯函数
 *      1) 不能以任何形式改动参数
 *      2) 不可以有异步
 *      3) 不可以对外部环境中的数据造成影响
 *
 * 5) bindActionCreators(actionsObjOfChildFn, store.dispatch): boundActions;
 *      - @actionsObjOfChildFn: 一个包含多个 acntionFn() 的对象
 *      - @store.dispatch: 用于绑定的 store.dispatch
 *      -
 *      - boundActions: 将传入的 actionObjOfChildFn 中的 ActionFn(); 绑定指定的 store.dispatch
 *      -
 *      - 绑定后，即可通过 boundActions.ActionFn();  调用传入 actionsObjOfChildFn 中的 ActionFn
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Reducer

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Reducer
 *
 *
 * 1) "一个" 数据仓库，有切仅有 "一个" reducer
 *    ( 通常情况，一个工程只有一个仓库，因此，一个系统，只有一个 reducer )
 *
 * 2) 为了方便管理，通常将 reducer 放在单独的文件中
 *
 * 3) reducer 何时被调用
 *      - 1> 当 store.dispatch，分发了一个 action，调用 reducer
 *      - 2> 当 创建 store 时，调用 reducer
 *          - 可以利用该创建时机，用 reducer 初始化状态
 *          - 创建仓库时，不传递任何默认状态
 *          - 将 reducer 参数 state 设置 默认值
 *
 * 4) reducer 内部通常使用 switch 判断 type 值
 *
 * 5) reducer 必须是一个没有副作用的纯函数
 *      * 为什么需要 "纯函数"
 *          - 纯函数有利用 测试 和 调试
 *          - 有利于还原数据
 *          - 有利于将来 和 react 结合使用
 *      * 具体要求
 *          - 不能改变参数( 若需要改变状态，则必须获取一个 "新的状态" )
 *          - 不能有 异步操作
 *          - 不能对外部环境造成影响
 *
 * 6) 因中大型项目中，操作比较复杂，数据结构比较复杂，则需要对 reducer 进行细分
 *      - import {combineReducers} from "redux";            // combineReducers({ tarName: tarReducer }): reducerFn;;
 *
 *        ( redux 中提供: 合并 reducer，返回一个新的 reducer
 *          该 reducer 管理一个对象，该对象中每个属性交由对应的 reducer 处理 )
 *
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Reducer-MiddleWare

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Reducer-MiddleWare                   // 实现 Redux 中间件的原理: 更改 仓库中的 dispatch 函数
 * 
 * 
 * 类似于插件，可以在不影响原本功能( 不该动原本代码 )的基础上，增加功能
 */

1) "中间件" 本身是一个函数，该函数 接收一个 store 参数
    表示创建的仓库，该仓库并非一个完整的仓库对象( 仅包含 getState，dispatch )

        * 由于创建仓库后需要自动运行设置的中间件函数，因此，需要创建仓库时，告诉仓库有哪些 中间件

        * 需要调用 applyMiddleware 函数，将函数的返回结果哦作为 createStore 的 第二 或 第三 个参数

2) 中间件函数 必须返回一个 dispatch 函数

3) applyMiddleware 函数，用于记录有哪些中间件，它返回一个函数

        * 该函数用于记录创建仓库的方法，然后又返回一个函数


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


            * 逆向赋值 next_dispatch
            * 正向运行 next_dispatch
                                                + ----------------- +
                                                |                   |
         + ------------------------------------>|      Store        |-------------------- +
         |                                      |     dispatch      |                     |
         |                                      |                   |                     |
         |                                      + ----------------- +                     |
         |                                                                                |
         |                                                                               \|/
         |      + ----------------- +           + ----------------- +           + ----------------- +
         |      |                   |           |                   |           |                   |
         |      |   MiddleWare_01   |<--- +     |   MiddleWare_02   |<--- +     |   MiddleWare_03   |
         |      |                   |     |     |                   |     |     |                   |
         |      + ----------------- +     |     + ----------------- +     |     + ----------------- +
         |                |               |               |               |               |          
         |               \|/              |              \|/              |              \|/          
         |      + ----------------- +     |     + ----------------- +     |     + ----------------- +
         |      |                   |     |     |                   |     |     |                   |
         + -----|   next_dispatch   |     + ----|   next_dispatch   |     + ----|   next_dispatch   |
                |                   |           |                   |           |                   |
                + ----------------- +           + ----------------- +           + ----------------- +


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### redux-saga

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * redux-saga
 * 
 * 
 * 用于处理 redux 中副作用的解决方案
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//



                 + ------ +    + ------------ +    + ------------ +    + ---------- +           + --------- +
       action    |        |    |              |    |              |    |            |   action  |           |
    ------------>|  saga  |--->|  MiddleWare  |--->|  MiddleWare  |--->|  dispatch  |---------->|  reducer  |
                 |        |    |              |    |              |    |            |           |           |
                 + ------ +    + ------------ +    + ------------ +    + ---------- +           + --------- +
                     |
                     |
                     |
                     |
                     + 
                 在最开始时，即启动一个 "saga 任务( 生成器函数 )"
                 saga为任务提供了大量功能以供使用
                 ( 功能以指令的形式出现，并出现在 yeild 的位置，因此可以被 saga中间件控制并执行 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### redux-actions

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 ** createAction(s)      // 创建一个多个 action & createActionFn
 *
 *
 * 1) createAction(type);                                           // 单个
 *    createAction(type, payloadCreator);
 *
 * 2) createActions(actionMap[, options]);                          // 多个
 *    createActions(actionMap, ...identityActions[, options]);      // options: 增加独特标识，区分同名 action
 *
 ** createActionFn.toString = actionType;       // toString(); 被重写
 */


/**
 ** handleAction(s)      // 创建一个或多个 reducer
 *
 *
 * 1) handleAction(type, reducer, defaultState);                    // 单个
 *    handleAction(type, reducerMap, defaultState);
 *
 * 2) handleActions(reducerMap. defaultState[, options]);           // 多个
 */


/**
 ** combineActions      // combineActions: 合并 '多个 actionType 对应 相同结构的处理函数'，降低代码耦合
 *                      // redux.combineReducers: 整合 reducer，模块化倒出
 *
 *
 * combineActions(...types);
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### react-redux

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * react-redux
 * 
 * 
 * 连接 Redux 和 React
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


        + ------------ +       + ----------------- +           + ------------------ +
        |              |       |                   |   data    |                    |
        |    Redux     |       |    react-redux    | --------> |       React        |
        |              | ====> |                   |   event   |  Render_interface  |
        |   database   |       |                   | --------> |  trigger_event     |
        |              |       |                   |           |                    |
        + ------------ +       + ----------------- +           + ------------------ +
                                                        
           公共数据仓库            连接 Redux 和 React           根据传递的数据渲染界面和触发事件
    
    
        react-redux: {
        
            <Provider/>         // 普通组件，无任何 UI界面，该组件将 redux_store 存放到指定上下文中
            connect             // 高阶组件，用于链接 仓库 和 组件
            ...
        }
        
        /**
         ** 结构模拟 <ContainerCmp> <PresentationalCmp/> </ContainerCmp>
         ** 实际结构 <PresentationalCmp ownProp={'组件外部传递的普通属性，最终仍然会作为普通属性传递'} />
         *
         *
         ** 1) connect(?mapStateToProps, ?(mapDispatchToProps ｜ creators: obj) ): hoc;
         ** 2) hoc(PresentationalCmp);
         *
         *
         * @mapStateToProps(state, ownProps):
         *      @state: 整个仓库的数据
         *      @ownProps: 组件外部传递的普通数据
         *
         * @mapDispatchToProps(dispatch): 将 store.dispatch 作为参数传递
         *      @dispatch: store.dispatch
         * @creators: 当事件发生时，会根据传入对象事件名调用 dispatch 处理相对应的 action
         *            ( connect 仅根据 creator 中事件名对应的 action 触发，无法做其他复杂处理 )
         *
         * @hoc:
         *      @PresentationalCmp
         *
         *
         ** conect(mapStateToProps);        // 不传递第二个参数时，则可以接受到 props.dispatch
         *                                  // ( 不推荐使用 )
         */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


    presentational_cmp           // 显示组件: 用于显示 UI 界面
    container_cmp                // 容器组件: 仅用于传递数据


                            + ------------------------ +                            + ------------------------ +            
                            |                          |      updata                |                          |        
                            |         Store            | <------------------------- |         Reducer          |        
                            |                          |                            |                          |            
                            + ------------------------ +                            + ------------------------ +            
                                                |                                                       |
                                                |   transfer_data                                       |
                                                |                                                       |
                 + ---------------------------- + ----------------------------- +                       |
                 |                              |                               |                       |
                 |                              |                               |                       |
    + ----- container_cmp ---- +    + ----- container_cmp ---- +    + ----- container_cmp ---- +        |
    |  + ------------------ +  |    |  + ------------------ +  |    |  + ------------------ +  |        |
    |  | presentational_cmp |  |    |  | presentational_cmp |  |    |  | presentational_cmp |  |        |
    |  + ------------------ +  |    |  + ------------------ +  |    |  + ------------------ +  |        |
    + ------------------------ +    + ------------------------ +    + ------------------------ +        |
                 |                              |                               |                       |
                 |                              |                               |                       |
                 + ---------------------------- + ----------------------------- +                       |
                                                |                                                       |
                                                |   trigger_event ( dispatch(action); )                 |
                                                |                                                       |
                                                + ----------------------------------------------------- +


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```












